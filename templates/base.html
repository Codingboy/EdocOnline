<!doctype html>
<html lang="en">
    <head>
        {% block head %}
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
		<script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js'></script>
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.4/socket.io.js"></script>
        <title>{% block title %}Edoc{% endblock title %}</title>
	<link rel="shortcut icon" href="/static/favicon.ico">
        <style>
            html
            {
                position: relative;
                min-height: 100%;
            }
            body
            {
                padding-top: 1%;
                padding-bottom: 5%;
                margin-bottom: 60px
            }
		#input
		{
			width: 75%;
		}
            .footer
            {
                position: absolute;
                bottom: 0;
                width: 100%;
                background-color: #f5f5f5;
            }
        </style>
        {% endblock head %}
		<script>
			/**
			 * Returns a random integer between min (inclusive) and max (inclusive)
			 * Using Math.round() will give you a non-uniform distribution!
			 */
			function getRandomInt(min, max)
			{
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}
			class Ring
			{
				constructor(pw, offset)
				{
					this.encodeRing = [];
					this.decodeRing = [];
					this.offset = offset;
					this.pw = pw.slice();
					for (let i=0; i<256; i++)
					{
						this.encodeRing.push(-1);
						this.decodeRing.push(-1);
					}
					let index = 0;
					while (this.pw.length < 256)
					{
						this.pw.push(this.pw[index]);
						index = (index+1)%256;
					}
					index = 0;
					for (let i=0; i<256; i++)
					{
						let emptyCounter = 0;
						let maxEmpty = 256-i;
						let targetEmpty = 1+(this.pw[i] % maxEmpty);
						while (emptyCounter < targetEmpty)
						{
							if (this.encodeRing[index] == -1)
							{
								emptyCounter++;
							}
							if (emptyCounter < targetEmpty)
							{
								index = (index+1)%256;
							}
						}
						this.encodeRing[index] = i;
					}
					for (let i=0; i<256; i++)
					{
						this.decodeRing[this.encodeRing[i]] = i;
					}
				}
				encode(plain)
				{
					let index = (this.offset+plain)%256;
					let encoded = this.encodeRing[index];
					this.offset = (this.offset+1)%256;
					return encoded;
				}
				decode(encoded)
				{
					let decoded = this.decodeRing[encoded] - this.offset;
					if (decoded < 0)
					{
						decoded += 256;
					}
					this.offset = (this.offset+1)%256;
					return decoded;
				}
			}
			class Torus
			{
				constructor(pw, offsets, seed)
				{
					if (typeof offsets == "undefined")
					{
						offsets = [];
						for (let i=0; i<8; i++)
						{ 
							offsets.push(getRandomInt(0, 255));
						}
					}
					if (typeof seed == "undefined")
					{
						seed = [];
						for (let i=0; i<256; i++)
						{ 
							seed.push(getRandomInt(1, 255));
						}
					}
					this.rings = [];
					this.seed = seed.slice();
					this.pw = pw.slice();
					for (let i=0; i<8; i++)
					{
						let ring = new Ring(this.pw, offsets[i]);
						this.rings.push(ring);
						this.pw.push(this.pw.shift());
					}
				}
				encode(plain)
				{
					let length = plain.length;
					while (plain.length%256 != 0)
					{
						plain.push(getRandomInt(0, 255));
					}
					let data = [];
					let processedBytes = 0;
					while (processedBytes < plain.length)
					{
						for (let i=0; i<256; i++)
						{
							//if (processedBytes < length)
							//{
								let encoded = plain[i] ^ this.seed[i];
								for (let j=0; j<8; j++)
								{ 
									if ((this.seed[i] & (1<<j)) != 0)
									{
										let ring = this.rings[j];
										encoded = ring.encode(encoded);
									}
								}
								data.push(encoded);
							//}
							processedBytes++;
						}
						for (let j=0; j<8; j++)
						{
							let ring = this.rings[j];
							let mixed = new Array(256);
							for (let i=0; i<256; i++)
							{
								mixed[i] = data[processedBytes-256+i];
							}
							for (let i=0; i<256; i++)
							{
								data[ring.encodeRing[i]+processedBytes-256] = mixed[i];
							}
						}
						for (let i=0; i<256; i++)
						{
							this.seed[i] = data[processedBytes-256+i] ^ this.seed[(i+1)%256];
							if (this.seed[i] == 0)
							{
								this.seed[i] = 1;
							}
						}
					}
					return data;
				}
				decode(encoded)
				{
					let length = encoded.length;
					let ret = [];
					let seeded = false;
					let processedBytes = 0;
					for (let i=0; i<length; i++)
					{
						let decoded = encoded[i];
						for (let j=8-1; j>=0; j--)
						{ 
							if ((this.seed[i%256] & (1<<j)) != 0)
							{
								let ring = this.rings[j];
								decoded = ring.decode(decoded);
							}
						}
						decoded = decoded ^ this.seed[i%256];
						ret.push(decoded);
						processedBytes++;
						if (i%256 == 256-1)
						{
							for (let j=8-1; j>=0; j--)
							{
								let ring = this.rings[j];
								let mixed = new Array(256);
								for (let i=0; i<256; i++)
								{
									mixed[i] = ret[processedBytes-256+i];
								}
								for (let i=0; i<256; i++)
								{
									ret[i+processedBytes-256] = mixed[ring.encodeRing[i]];
								}
							}
							seeded = true;
							for (let j=0; j<256; j++)
							{
								this.seed[j] = encoded[j-256+i+1] ^ this.seed[(j+1)%256];
								if (this.seed[j] == 0)
								{
									this.seed[j] = 1;
								}
							}
						}
					}
					if (!seeded)
					{
						for (let i=0; i<256; i++)
						{
							this.seed[i] = getRandomInt(1, 256-1);
						}
					}
					return ret;
				}
				getOffsets()
				{
					let offsets = [];
					for (let i=0; i<8; i++)
					{
						offsets.push(this.rings[i].offset);
					}
					return offsets;
				}
				getSeed()
				{
					let seed = [];
					for (let i=0; i<256; i++)
					{
						seed[i] = this.seed[i];
					}
					return seed;
				}
				setOffsets(offsets)
				{
					for (let i=0; i<8; i++)
					{
						this.rings[i].offset = offsets[i];
					}
				}
				setSeed(seed)
				{
					for (let i=0; i<256; i++)
					{
						this.seed[i] = seed[i];
					}
				}
			}
			function send()
			{
				let input = document.getElementById("input");
				if (input.value == "")
				{
					return;
				}
				let json = {};
				json["username"] = username;
				if (torus === null)
				{
					json["encoded"] = false;
					json["plainMessage"] = input.value;
				}
				else
				{
					let message = input.value;
					json["encoded"] = true;
					json["offsets"] = torus.getOffsets();
					json["seed"] = torus.getSeed();
					let plainMessage = [];
					for (let i=0; i<message.length; i++)
					{
						plainMessage.push(message.charCodeAt(i));
					}
					let encodedMessage = torus.encode(plainMessage);
					json["encodedMessage"] = encodedMessage;
				}
				input.value = "";
				console.log(json);
				socket.emit("sendMessage", json);
			}
			function usePassword()
			{
				let password = document.getElementById("password").value;
				if (password == "")
				{
					torus = null;
				}
				else
				{
					updatePassword(password);
				}
			}
			function usePasswordFile()
			{
				let begin = parseInt(document.getElementById("begin").value);
				let length = parseInt(document.getElementById("length").value);
				if (passwordFileContent.length >= begin+length)
				{
					let password = passwordFileContent.substring(begin, begin+length);
					updatePassword(password);
				}
				else
				{
					alert(passwordFileContent.length);
				}
			}
			function updatePassword(pw)
			{
				let asInt = [];
				for (let i=0; i<pw.length; i++)
				{
					asInt.push(pw.charCodeAt(i));
				}
				torus = new Torus(asInt);
			}
			function useUsername()
			{
				let request = db.transaction(["settings"], "readwrite").objectStore("settings").delete(0);
				request.onerror = function(event)
				{
					alert("DatabaseError");
				};
				request.onsuccess = function(event)
				{
					username = document.getElementById("username").value;
					let settings = {"id":0, "username":username};
					let req = db.transaction(["settings"], "readwrite").objectStore("settings").put(settings);
					req.onerror = function(event)
					{
						alert("DatabaseError");
					};
					req.onsuccess = function(event)
					{
					};
				};
			}
			function readSingleFile(e)
			{
				var file = e.target.files[0];
				if (!file)
				{
					return;
				}
				var reader = new FileReader();
				reader.onload = function(e)
				{
					passwordFileContent = e.target.result;
					let begin = parseInt(document.getElementById("begin").value);
					let length = parseInt(document.getElementById("length").value);
					let contentLength = passwordFileContent.length;
					if (length > contentLength)
					{
						alert("passwordfile is very small!");
					}
					else
					{
						let maxValue = contentLength-length;
						document.getElementById("begin").value = getRandomInt(0, maxValue);
						usePasswordFile();
					}
				};
				reader.readAsText(file);
			}
			function initDB(callback)
			{
				window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
				window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
				window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
				let request = window.indexedDB.open("edoc", 1);
				request.onupgradeneeded = function(event)
				{
					db = event.target.result;
					if (!db.objectStoreNames.contains("settings"))
					{
						db.createObjectStore("settings", {keyPath: "id"});
					}
				};
				request.onsuccess = function(event)
				{
					db = event.target.result;
					callback(event);
				};
				request.onerror = function(event)
				{
					alert("DBError");
				};
			}
		</script>
    </head>
    <body>
        {% block body %}
            {% block bodycontent %}
		<center>
            <div class='container'>
                <div class='row'>
                    <div class='col-xs-12'>
						<form>
							Username: <input type="text" name="username" id="username"><input type="button" value="Use Username" onclick="useUsername()"><br/>
							Password: <input type="password" name="password" id="password"><input type="button" value="Use Password" onclick="usePassword()"><br/>
							Passwordfile: <input type="file" name="passwordfile" id="passwordfile"><input type="number" name="begin" id="begin" value="0" min="0"><input type="number" name="length" id="length" value="256" min="1" max ="256"><input type="button" value="Use Passwordfile" onclick="usePasswordFile()"><br/>
							<textarea disabled rows="30" cols="126" id="output"></textarea><br/>
							<input type="text" name="input" id="input"><input type="button" value="Send" onclick="send()">
						</form>
						<script>
							let username = "Unknown User";
							document.getElementById("username").value = username;
							let torus = null;
							let passwordFileContent = "";
							document.getElementById("passwordfile").addEventListener("change", readSingleFile, false);
							let socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);
							socket.open();
							socket.on("receiveMessage", function(json)
							{
								console.log(json);
								let user = json["username"];
								let encoded = json["encoded"];
								let message = "";
								if (encoded)
								{
									if (torus)
									{
										let offsets = json["offsets"];
										let seed = json["seed"];
										torus.setSeed(seed);
										torus.setOffsets(offsets);
										let encodedMessage = json["encodedMessage"];
										let decodedMessage = torus.decode(encodedMessage);
										message = "["+user+"] ";
										for (let i=0; i<decodedMessage.length; i++)
										{
											message += String.fromCharCode(decodedMessage[i]);
										}
										message += "\n";
									}
								}
								else
								{
									let plainMessage = json["plainMessage"];
									message = "["+user+"] (unencoded) "+plainMessage+"\n";
								}
								document.getElementById("output").value += message;
							});
							let db = null;
							initDB(function(event)
							{
								let req = db.transaction(["settings"]).objectStore("settings").get(0);
								req.onerror = function(event)
								{
									alert("DatabaseError");
								};
								req.onsuccess = function(event)
								{
									if (req.result)
									{
										username = req.result["username"];
										document.getElementById("username").value = username;
									}
								};
							});
							document.getElementById("input").addEventListener ("keydown", function(event) {
								if (event.keyCode == 13)
								{
									send();
								}
							});
						</script>
                    </div>
		</div>
            </div>
		</center>
            {% endblock bodycontent %}
            {% block footer %}
            <footer class='footer'>
		<center>
                <div class='container'>
                    <span class='text-muted'><a href='/impressum'>Impressum</a></span>
                </div>
		</center>
            </footer>
            {% endblock footer %}
        {% endblock body %}
    </body>
</html>
